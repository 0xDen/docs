{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Fobnail? The Fobnail Token is a tiny open-source hardware USB device that provides a means for a user/administrator/enterprise to determine the integrity of a system. To make this determination, Fobnail functions as an attestor capable of validating attestation assertions made by the system. As an independent device, Fobnail provides a high degree of assurance that an infected system cannot influence Fobnail as it inspects the attestations made by the system. Fobnail software is an open-source implementation of the iTurtle security architecture concept presented at HotSec07; in addition, it will leverage industry standards like TCG D-RTM trusted execution environment and IEFT RATS. The Fobnail project aims to provide a reference architecture for building offline integrity measurement servers on the USB device and clients running in Dynamically Launched Measured Environments (DLME). It allows the Fobnail owner to verify the trustworthiness of the running system before performing any sensitive operation. Fobnail does not need an Internet connection what makes it immune to the network stack and remote infrastructure attacks. It brings the power of solid system integrity validation to the individual in a privacy-preserving solution. Table of content Project description Fobnail architecture Environment setup Flashing sample applications Resources","title":"Intro"},{"location":"#what-is-fobnail","text":"The Fobnail Token is a tiny open-source hardware USB device that provides a means for a user/administrator/enterprise to determine the integrity of a system. To make this determination, Fobnail functions as an attestor capable of validating attestation assertions made by the system. As an independent device, Fobnail provides a high degree of assurance that an infected system cannot influence Fobnail as it inspects the attestations made by the system. Fobnail software is an open-source implementation of the iTurtle security architecture concept presented at HotSec07; in addition, it will leverage industry standards like TCG D-RTM trusted execution environment and IEFT RATS. The Fobnail project aims to provide a reference architecture for building offline integrity measurement servers on the USB device and clients running in Dynamically Launched Measured Environments (DLME). It allows the Fobnail owner to verify the trustworthiness of the running system before performing any sensitive operation. Fobnail does not need an Internet connection what makes it immune to the network stack and remote infrastructure attacks. It brings the power of solid system integrity validation to the individual in a privacy-preserving solution.","title":"What is Fobnail?"},{"location":"#table-of-content","text":"Project description Fobnail architecture Environment setup Flashing sample applications Resources","title":"Table of content"},{"location":"architecture/","text":"Fobnail architecture Fobnail provisioning The purpose of provisioning is to provide a controlled process for an individual to take ownership and configure the Fobnail. During the provisioning process the token should provide the following information to the provisioner: A public key to use for generating an identity certificate A public key to use for generating an encryption certificate Metadata about the token, e.g. model, serial number, etc A token will consider itself provisioned when it is in an unprovisioned state and a provisioner sends it the following information: A certificate chain for the provisioner An identity certificate containing the public key the token generated An encryption certificate containing the public key the token generated Either during provisioning or post provisioning a provisioner may send the following information, RIM Database Policy Database Attestation Protected Object This information must be signed by private key for the provisioner identity certificate contained in the provisioner Certificate Chain. Fobnail provisioning diagram Platform provisioning Fobnail architecture consists of two main functionalities - provisioning and attestation. We need to provision a Fobnail token and platform. The platform provisioning is split into remote provisioning and local provisioning. During the remote provisioning, the platform can connect to the platform owner. The platform owner verifies the platform state and provides the RIM and attestation policies to the Fobnail token. The platform receives an attestation identity certificate that specifies the platform. The certificate is based on platform metadata (CPU serial, MAC) and the AIK public part. Remote platform provisioning diagram In the case of local provisioning, the Fobnail token takes the platform owner role. The Fobnail token does not receive the policies, and default policies policies are used during the attestation. Local platform provisioning diagram Attestation Fobnail role in the attestation of a system is to evaluate an Attestation Token and arrive at a decision whether the attested platform represents a good state. Fobnail is not an enforcement point for this decision and can only provide a physical and digital response to convey its decision. The physical response assumes that a user is monitoring the Fobnail Token and will take appropriate enforcement action(s). A digital response comes in the form of an Authorization Token that is returned back to the system. The assumption here is that the Authorization Token can securely be used by the system to enforce the decision or forwarded to an external entity that can enforce the decision. Attestation diagram","title":"Fobnail architecture"},{"location":"architecture/#fobnail-architecture","text":"","title":"Fobnail architecture"},{"location":"architecture/#fobnail-provisioning","text":"The purpose of provisioning is to provide a controlled process for an individual to take ownership and configure the Fobnail. During the provisioning process the token should provide the following information to the provisioner: A public key to use for generating an identity certificate A public key to use for generating an encryption certificate Metadata about the token, e.g. model, serial number, etc A token will consider itself provisioned when it is in an unprovisioned state and a provisioner sends it the following information: A certificate chain for the provisioner An identity certificate containing the public key the token generated An encryption certificate containing the public key the token generated Either during provisioning or post provisioning a provisioner may send the following information, RIM Database Policy Database Attestation Protected Object This information must be signed by private key for the provisioner identity certificate contained in the provisioner Certificate Chain.","title":"Fobnail provisioning"},{"location":"architecture/#fobnail-provisioning-diagram","text":"","title":"Fobnail provisioning diagram"},{"location":"architecture/#platform-provisioning","text":"Fobnail architecture consists of two main functionalities - provisioning and attestation. We need to provision a Fobnail token and platform. The platform provisioning is split into remote provisioning and local provisioning. During the remote provisioning, the platform can connect to the platform owner. The platform owner verifies the platform state and provides the RIM and attestation policies to the Fobnail token. The platform receives an attestation identity certificate that specifies the platform. The certificate is based on platform metadata (CPU serial, MAC) and the AIK public part.","title":"Platform provisioning"},{"location":"architecture/#remote-platform-provisioning-diagram","text":"In the case of local provisioning, the Fobnail token takes the platform owner role. The Fobnail token does not receive the policies, and default policies policies are used during the attestation.","title":"Remote platform provisioning diagram"},{"location":"architecture/#local-platform-provisioning-diagram","text":"","title":"Local platform provisioning diagram"},{"location":"architecture/#attestation","text":"Fobnail role in the attestation of a system is to evaluate an Attestation Token and arrive at a decision whether the attested platform represents a good state. Fobnail is not an enforcement point for this decision and can only provide a physical and digital response to convey its decision. The physical response assumes that a user is monitoring the Fobnail Token and will take appropriate enforcement action(s). A digital response comes in the form of an Authorization Token that is returned back to the system. The assumption here is that the Authorization Token can securely be used by the system to enforce the decision or forwarded to an external entity that can enforce the decision.","title":"Attestation"},{"location":"architecture/#attestation-diagram","text":"","title":"Attestation diagram"},{"location":"debugging/","text":"Debugging nRF52840 dongle It is possible to debug the nRF82540 dongle wit ha JLink debugger. The dongle contains a depopulated JLink header and a 10 pads for connecting the ribbon needle connector or a straight ribbon. Prerequisites For this purpose we will need: nRF82540 Development Kit (PCA10056) Needle 10-pin cable with ribbon 1.27mm pitch for use with Development Kit One may use a JLink pro with a suitable adapter to the correct ribbon cable with needle connector. However JLink PRO is very expensive (25x more expensive than development kit). Also if using a development kit, it only uses a voltage o 3V to program and debug applications so we need to slightly modify the dongle for development kit use. Firstly cut the SB2 and solder SB1. This will allow to use VDD_OUT pin as a power source. Solder jumper wires (male-end) to the following pads (color convention may be different, but in the whole documentation we will use the following color convention): Description: black wire - male-male jumper wire (GND) violet - male-male jumper wire (VDD_OUT) IMPORTANT! Do not connect the dongle to USB when SB2 is cut and SB1 is soldered. Connection How does it work? The nRF82540 development kit can program external chips via the debug out connector. In order to program the nRF52840 dongle: Connect Needle 10-pin cable with ribbon 1.27mm pitch to the debug out header. The ribbon has an edging which fits into the header only in one orientation. Connect black write from the dongle to one of the red GND pin on the female header on the left (according to picture). Connect the violet wire from the dongle to the red VDD pin on the female header on the left (according to picture). The development kit will source VDD power 3V which is suitable for the programming with the development kit. The dongle automatically uses 5V on the VDD and VBUS' (connected to EXT_GND_DETECT) which will damage the dev kit. Also the dev kit selects which chip to program based on the power supply of the target chip: if VDD is present on the debug out connector then the external chip is programmed otherwise the dev kit's on-board chip is programmed So in order to program the dongle with the dev kit we have to supply compatible voltage from the dev kit to the dongle. That is why the dongle required modifications to source power from VDD_OUT pin. Connect the needle 10-pin cable with ribbon 1.27mm pitch to the JLink connector on the dongle (see picture below, marked in red). The needle has 3 positions pins which will fit in a single orientation only. Programming and recovery Now that we have prepared correct connections between dev kit and the dongle we may proceed with flashing. For example if we erase whole chip along with UICR which sets the voltage regulator on the dongle we will not be able to program it via dev kit unless we do the modifications described before. The nRF52840 chip on the dongle hardware is configured in high voltage mode. This uses REG0 to lower the chip supply voltage (VDD), and the default value is 1.8 V, configured by the REGOUT0 register in UICR. This is too low to be used with the on-board programmer on the nRF52840 DK, so erasing or programming with a firmware that does not configure the regulator for a higher VDD will leave it in a state where it cannot be re-programmed from a dev kit. To avoid problems if you are using a debugger without level shifter (such as a nRF52840 DK): Avoid erasing the UICR of the chip (i.e. do not do a full chip erase). If you must erase the UICR, make sure that you do not reset the board until after you have programmed either REGOUT0 directly or firmware that sets it. Alternatively, modify the dongle as explained under External regulated source and supply the dongle directly from the nRF52 DK (assuming it is used as a debugger). In our case we have done the modifications and will recover the original bootloader: wget https://devzone.nordicsemi.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-00-13/pca10059_5F00_bootloader.zip unzip pca10059_5F00_bootloader.zip Copy the file graviton_bootloader_mbr_v1.0.1-[nRF5_SDK_15.0.1-1.alpha_f76d012].hex into the directory mounted inside thee fobnail-sdk container. Grab the dongle with needle and hold it tight so that the needle will connect with the pins. Execute nrfjprog -f NRF52 --program graviton_bootloader_mbr_v1.0.1-[nRF5_SDK_15.0.1-1.alpha_f76d012].hex --chiperase Disconnect the needle and the wires from dongle and devkit. Connect violet and green wire. Plug the dongle into computer USB port while holding reset button. Check if the LED diode is blinking red which indicates teh original bootloader mode has been entered. Also the dmesg that the USB Nordic bootloader has been detected. Debugging There is an incompatibility in the debug header of the dongle and dev kit: The 5th pin of debug out header (second picture) is connected the the dev kit's ground, while 5th pin on the JLink header on the dongle is connected to VBUS' which is 5V when the dongle is connected to the USB. This makes the debugging of the dongle effectively impossible when the dongle is connected to the USB port. However, when it is supplied with power via VDD_OUT, it is possible to debug it, but it will be impossible to debug USB connection. The right way to debug the dongle without modifications is to use the P1 header on the dongle which matches 100% the pinout of debug out header of the dev kit. Note that the modifications are still needed if the UICR is removed to supply the VDD of the dongle with 3V from dev kit. In order to connect to the P1 header one would need a SMT 2x5 pin header pitch 1.27mm, the same as used on the debug out header on the dev kit. Here you may find big pictures of such header: https://blog.adafruit.com/2019/01/17/new-product-mini-swd-0-05-pitch-connector-10-pin-smt-box-header/ Until we do not need to debug USB connection, we may use a blinky sample as a reference program to be debugged. Refer to Flashing sample applications how to build the samples. Now we will try to flash them with the needle connector instead of USB DFU. Inside the fobnail SDK container execute: make clean make mcuboot_demo make blinky_demo Ensure the chip is erased (ti simulate a fault and that we lost UICR) so connect the black and violet wires to the dev kit's GND and VDD, grab the dongle with needle and hold it tight so that the needle will connect with the pins. Execute make erase . Flash the nRF52840 dongle while holding the needle: nrfjprog -f NRF52 --program graviton_bootloader_mbr_v1.0.1-\\[nRF5_SDK_15.0.1-1.alpha_f76d012\\].hex Unplug and plug the violet wire to dev kit's VDD. This will initiate a reset of the dongle (the Jlink header does not expose reset signal, only P1 header has reset signal). Notice the red LED should start blinking indicating Nordic's bootloader mode. It has entered the bootloader mode automatically because USB connection has not been detected thus the rest switch was not needed. Solder SB2 and desolder SB1. Unplug black and violet wires. Unplug the needle connector. Black wire floating safely. Plug the dongle into USB and flash the samples using DFU as instructed in Flashing sample applications . Since the Nordic's bootloader is stuck when not connected to USB, and we cannot use dev kit to debug when dongle is connected to USB, the guide below presents how to debug a blinky sample on the nRF82540 chip present on the dev kit. Although it will apply to the dongle as well if you solder the P1 header and connect the straight ribbon cable to debug out and P1 header. If you have a straight ribbon cable and P1 header soldered you may use the dongle instead. Disconnect the dongle from the dev kit. west build -b nrf52840dk_nrf52840 -d build/blinky zephyr/samples/basic/blinky nrfjprog --eraseall -f nrf52 nrfjprog -f nrf52 --program build/blinky/zephyr/zephyr.hex Now the green LED1 on the dev kit should start blinking. Launch JLink GDB server inside the container: JLinkGDBServerCLExe -select USB -device nRF52840_xxAA -endian little \\ -if SWD -speed 4000 -ir -noLocalhostOnly & Connect with GDB to the nRF52840 chip on the dev kit: gdb (gdb) file build/blinky/zephyr/zephyr.elf (gdb) target remote localhost:2331 Execute the following commands in GDB to start debugging [TBD]","title":"Debugging nRF52840 dongle"},{"location":"debugging/#debugging-nrf52840-dongle","text":"It is possible to debug the nRF82540 dongle wit ha JLink debugger. The dongle contains a depopulated JLink header and a 10 pads for connecting the ribbon needle connector or a straight ribbon.","title":"Debugging nRF52840 dongle"},{"location":"debugging/#prerequisites","text":"For this purpose we will need: nRF82540 Development Kit (PCA10056) Needle 10-pin cable with ribbon 1.27mm pitch for use with Development Kit One may use a JLink pro with a suitable adapter to the correct ribbon cable with needle connector. However JLink PRO is very expensive (25x more expensive than development kit). Also if using a development kit, it only uses a voltage o 3V to program and debug applications so we need to slightly modify the dongle for development kit use. Firstly cut the SB2 and solder SB1. This will allow to use VDD_OUT pin as a power source. Solder jumper wires (male-end) to the following pads (color convention may be different, but in the whole documentation we will use the following color convention): Description: black wire - male-male jumper wire (GND) violet - male-male jumper wire (VDD_OUT) IMPORTANT! Do not connect the dongle to USB when SB2 is cut and SB1 is soldered.","title":"Prerequisites"},{"location":"debugging/#connection","text":"How does it work? The nRF82540 development kit can program external chips via the debug out connector. In order to program the nRF52840 dongle: Connect Needle 10-pin cable with ribbon 1.27mm pitch to the debug out header. The ribbon has an edging which fits into the header only in one orientation. Connect black write from the dongle to one of the red GND pin on the female header on the left (according to picture). Connect the violet wire from the dongle to the red VDD pin on the female header on the left (according to picture). The development kit will source VDD power 3V which is suitable for the programming with the development kit. The dongle automatically uses 5V on the VDD and VBUS' (connected to EXT_GND_DETECT) which will damage the dev kit. Also the dev kit selects which chip to program based on the power supply of the target chip: if VDD is present on the debug out connector then the external chip is programmed otherwise the dev kit's on-board chip is programmed So in order to program the dongle with the dev kit we have to supply compatible voltage from the dev kit to the dongle. That is why the dongle required modifications to source power from VDD_OUT pin. Connect the needle 10-pin cable with ribbon 1.27mm pitch to the JLink connector on the dongle (see picture below, marked in red). The needle has 3 positions pins which will fit in a single orientation only.","title":"Connection"},{"location":"debugging/#programming-and-recovery","text":"Now that we have prepared correct connections between dev kit and the dongle we may proceed with flashing. For example if we erase whole chip along with UICR which sets the voltage regulator on the dongle we will not be able to program it via dev kit unless we do the modifications described before. The nRF52840 chip on the dongle hardware is configured in high voltage mode. This uses REG0 to lower the chip supply voltage (VDD), and the default value is 1.8 V, configured by the REGOUT0 register in UICR. This is too low to be used with the on-board programmer on the nRF52840 DK, so erasing or programming with a firmware that does not configure the regulator for a higher VDD will leave it in a state where it cannot be re-programmed from a dev kit. To avoid problems if you are using a debugger without level shifter (such as a nRF52840 DK): Avoid erasing the UICR of the chip (i.e. do not do a full chip erase). If you must erase the UICR, make sure that you do not reset the board until after you have programmed either REGOUT0 directly or firmware that sets it. Alternatively, modify the dongle as explained under External regulated source and supply the dongle directly from the nRF52 DK (assuming it is used as a debugger). In our case we have done the modifications and will recover the original bootloader: wget https://devzone.nordicsemi.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-00-13/pca10059_5F00_bootloader.zip unzip pca10059_5F00_bootloader.zip Copy the file graviton_bootloader_mbr_v1.0.1-[nRF5_SDK_15.0.1-1.alpha_f76d012].hex into the directory mounted inside thee fobnail-sdk container. Grab the dongle with needle and hold it tight so that the needle will connect with the pins. Execute nrfjprog -f NRF52 --program graviton_bootloader_mbr_v1.0.1-[nRF5_SDK_15.0.1-1.alpha_f76d012].hex --chiperase Disconnect the needle and the wires from dongle and devkit. Connect violet and green wire. Plug the dongle into computer USB port while holding reset button. Check if the LED diode is blinking red which indicates teh original bootloader mode has been entered. Also the dmesg that the USB Nordic bootloader has been detected.","title":"Programming and recovery"},{"location":"debugging/#debugging","text":"There is an incompatibility in the debug header of the dongle and dev kit: The 5th pin of debug out header (second picture) is connected the the dev kit's ground, while 5th pin on the JLink header on the dongle is connected to VBUS' which is 5V when the dongle is connected to the USB. This makes the debugging of the dongle effectively impossible when the dongle is connected to the USB port. However, when it is supplied with power via VDD_OUT, it is possible to debug it, but it will be impossible to debug USB connection. The right way to debug the dongle without modifications is to use the P1 header on the dongle which matches 100% the pinout of debug out header of the dev kit. Note that the modifications are still needed if the UICR is removed to supply the VDD of the dongle with 3V from dev kit. In order to connect to the P1 header one would need a SMT 2x5 pin header pitch 1.27mm, the same as used on the debug out header on the dev kit. Here you may find big pictures of such header: https://blog.adafruit.com/2019/01/17/new-product-mini-swd-0-05-pitch-connector-10-pin-smt-box-header/ Until we do not need to debug USB connection, we may use a blinky sample as a reference program to be debugged. Refer to Flashing sample applications how to build the samples. Now we will try to flash them with the needle connector instead of USB DFU. Inside the fobnail SDK container execute: make clean make mcuboot_demo make blinky_demo Ensure the chip is erased (ti simulate a fault and that we lost UICR) so connect the black and violet wires to the dev kit's GND and VDD, grab the dongle with needle and hold it tight so that the needle will connect with the pins. Execute make erase . Flash the nRF52840 dongle while holding the needle: nrfjprog -f NRF52 --program graviton_bootloader_mbr_v1.0.1-\\[nRF5_SDK_15.0.1-1.alpha_f76d012\\].hex Unplug and plug the violet wire to dev kit's VDD. This will initiate a reset of the dongle (the Jlink header does not expose reset signal, only P1 header has reset signal). Notice the red LED should start blinking indicating Nordic's bootloader mode. It has entered the bootloader mode automatically because USB connection has not been detected thus the rest switch was not needed. Solder SB2 and desolder SB1. Unplug black and violet wires. Unplug the needle connector. Black wire floating safely. Plug the dongle into USB and flash the samples using DFU as instructed in Flashing sample applications . Since the Nordic's bootloader is stuck when not connected to USB, and we cannot use dev kit to debug when dongle is connected to USB, the guide below presents how to debug a blinky sample on the nRF82540 chip present on the dev kit. Although it will apply to the dongle as well if you solder the P1 header and connect the straight ribbon cable to debug out and P1 header. If you have a straight ribbon cable and P1 header soldered you may use the dongle instead. Disconnect the dongle from the dev kit. west build -b nrf52840dk_nrf52840 -d build/blinky zephyr/samples/basic/blinky nrfjprog --eraseall -f nrf52 nrfjprog -f nrf52 --program build/blinky/zephyr/zephyr.hex Now the green LED1 on the dev kit should start blinking. Launch JLink GDB server inside the container: JLinkGDBServerCLExe -select USB -device nRF52840_xxAA -endian little \\ -if SWD -speed 4000 -ir -noLocalhostOnly & Connect with GDB to the nRF52840 chip on the dev kit: gdb (gdb) file build/blinky/zephyr/zephyr.elf (gdb) target remote localhost:2331 Execute the following commands in GDB to start debugging [TBD]","title":"Debugging"},{"location":"description/","text":"Project description The Fobnail project is an implementation of the iTurtle idea shown in the research paper [1] . The iTurtle concept presents the portable device that is a security USB stick, which provides platform trustworthiness checks. The result of the integrity check must be presented in an easy, visible way - for example with the LED. We (3mdeb team) want to provide the open source implementation of the iTurtle device - the Fobnail Token. Our goal is to create a scalable, flexible implementation which will be the a core building-block for the future security solutions (created by community) based on DRTM payloads. The Fobnail Token architecture concept is based on the IEFT specification - Remote ATtestation ProcedureS (RATS) [2] . The architecture supports Fobnail Token provisioning [3] , a Platform (Attester) provisioning [4] [5] , and the attestation [6] . Currently, there is no open source implementation of the USB attestation device. During the Fobnail Token provisioning [3] , the Platform Owner creates the identity and encryption certificates that are used by the Attester to the Fobnail Token verification. The Fobnail Token verifies the Platform Owner certificate chain and generates the identity and encryption key pair. The Fobnail Token obtains the metadata (CPU serial) and conveys the encrypted public key parts and metadata to the Platform Owner. The received data is decrypted and the Platform Owner creates identity and encryption certificates, that are provided to the Fobnail Token. The Platform provisioning is split into external provisioning (which is out of grant application scope) [4] and local provisioning [5]. In the case of local provisioning [5] , the Fobnail Token takes the Platform Owner role. The Fobnail Token receives the Attester metadata (CPU serial, MAC, and EK certificate checksum) and generates the checksum. The metadata checksum is used for the Platform verification during the attestation. The Fobnail Token uses default policies during the local attestation. The attestation architecture [6] is based on the Reference Interaction Model for Challenge-Response-based Remote Attestation (CHARRA) [7] . This is the IEFT attestation standard, which specifies the communication between the Attester and the Verifier (Fobnail). The Fobnail provides the ability to perform attestation in absence of any connectivity. During the attestation development, we will use the proof-of-concept implementation [8] of the proposed architecture, which is developed by the Fraunhofer Institute. To demponstrate the capabilities of implemented solution, we will create the example use case that uses the TrenchBoot - our previous NLnet project [9] , to verify the integrity of the system firmware, D-RTM Configuration Environment (DCE), Linux Kernel, and initrd. The main use case that will be presented as a demonstration is boot time attestation. The Fobnail Token will be used to verify an operating system during boot time. We will run inside DLME [10] (Dynamically Launched Measured Environment) the Zephyr RTOS which will check if the measurements of the operating system met the reference measurements in the Fobnail Token. If OS is compromised the Fobnail Token warns the user and Zephyr RTOS prevents a platform from booting. The Fobnail has the potential to scale up in the future. The Fobnail architecture could be adapted for devices using different buses than USB. We would like to implement another DRTM based use case (that is out of the scope of this grant application) for example runtime OS attestation. The Fobnail could be used to check if the runtime state of the platform is trusted. It could be base on one of the existing projects such as Linux Kernel Runtime Guard [11] . It could be useful to check the integrity of the Linux Kernel before performing sensitive operations. [1] \"Turtles All The Way Down: Research Challenges in User-Based Attestation\", Jonathan M. McCune, Adrian Perrig, Arvind Seshadri, Leendert van Doorn, https://www.usenix.org/legacy/event/hotsec07/tech/full_papers/mccune/mccune_html/index.html [2] \"Remote Attestation Procedures Architecture\", H. Birkholz, D. Thaler, M. Richardson, N. Smith, W. Pan, https://datatracker.ietf.org/doc/draft-ietf-rats-architecture/ [3] \"Fobnail Token provisioning - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://drive.google.com/file/d/143wW4zWcLbedbuaWMlQpC9f_CMCcXdLH/view?usp=sharing [4] \"External platform provisioning - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://drive.google.com/file/d/1WGBbO9bCFlnarPCZzrKXUjpH4hzbf5l9/view?usp=sharing [5] \"Local platform provisioning - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://drive.google.com/file/d/12gqhdKBlFAMOOkjZu99RPVI_iy_nWfxE/view?usp=sharing [6] \"Local platform provisioning - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://drive.google.com/file/d/1L3CBQsh-qQ4I-7mDj0OYdpK73p_bgKS0/view?usp=sharing [7] \"Attestation - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://tools.ietf.org/id/draft-birkholz-rats-reference-interaction-model-00.html [8] \"CHARRA: CHAllenge-Response based Remote Attestation with TPM 2.0\" https://github.com/Fraunhofer-SIT/charra [9] \"Open Source DRTM implementation with TrenchBoot for AMD processors\" https://nlnet.nl/project/OpenDRTM/ [10] \"The TCG Dynamic Root for Trusted Measurement\", Lee Wilson https://trustedcomputinggroup.org/wp-content/uploads/DRTM-Specification-Overview_June2013.pdf [11] \"LKRG - Linux Kernel Runtime Guard\" https://www.openwall.com/lkrg/","title":"Project description"},{"location":"description/#project-description","text":"The Fobnail project is an implementation of the iTurtle idea shown in the research paper [1] . The iTurtle concept presents the portable device that is a security USB stick, which provides platform trustworthiness checks. The result of the integrity check must be presented in an easy, visible way - for example with the LED. We (3mdeb team) want to provide the open source implementation of the iTurtle device - the Fobnail Token. Our goal is to create a scalable, flexible implementation which will be the a core building-block for the future security solutions (created by community) based on DRTM payloads. The Fobnail Token architecture concept is based on the IEFT specification - Remote ATtestation ProcedureS (RATS) [2] . The architecture supports Fobnail Token provisioning [3] , a Platform (Attester) provisioning [4] [5] , and the attestation [6] . Currently, there is no open source implementation of the USB attestation device. During the Fobnail Token provisioning [3] , the Platform Owner creates the identity and encryption certificates that are used by the Attester to the Fobnail Token verification. The Fobnail Token verifies the Platform Owner certificate chain and generates the identity and encryption key pair. The Fobnail Token obtains the metadata (CPU serial) and conveys the encrypted public key parts and metadata to the Platform Owner. The received data is decrypted and the Platform Owner creates identity and encryption certificates, that are provided to the Fobnail Token. The Platform provisioning is split into external provisioning (which is out of grant application scope) [4] and local provisioning [5]. In the case of local provisioning [5] , the Fobnail Token takes the Platform Owner role. The Fobnail Token receives the Attester metadata (CPU serial, MAC, and EK certificate checksum) and generates the checksum. The metadata checksum is used for the Platform verification during the attestation. The Fobnail Token uses default policies during the local attestation. The attestation architecture [6] is based on the Reference Interaction Model for Challenge-Response-based Remote Attestation (CHARRA) [7] . This is the IEFT attestation standard, which specifies the communication between the Attester and the Verifier (Fobnail). The Fobnail provides the ability to perform attestation in absence of any connectivity. During the attestation development, we will use the proof-of-concept implementation [8] of the proposed architecture, which is developed by the Fraunhofer Institute. To demponstrate the capabilities of implemented solution, we will create the example use case that uses the TrenchBoot - our previous NLnet project [9] , to verify the integrity of the system firmware, D-RTM Configuration Environment (DCE), Linux Kernel, and initrd. The main use case that will be presented as a demonstration is boot time attestation. The Fobnail Token will be used to verify an operating system during boot time. We will run inside DLME [10] (Dynamically Launched Measured Environment) the Zephyr RTOS which will check if the measurements of the operating system met the reference measurements in the Fobnail Token. If OS is compromised the Fobnail Token warns the user and Zephyr RTOS prevents a platform from booting. The Fobnail has the potential to scale up in the future. The Fobnail architecture could be adapted for devices using different buses than USB. We would like to implement another DRTM based use case (that is out of the scope of this grant application) for example runtime OS attestation. The Fobnail could be used to check if the runtime state of the platform is trusted. It could be base on one of the existing projects such as Linux Kernel Runtime Guard [11] . It could be useful to check the integrity of the Linux Kernel before performing sensitive operations. [1] \"Turtles All The Way Down: Research Challenges in User-Based Attestation\", Jonathan M. McCune, Adrian Perrig, Arvind Seshadri, Leendert van Doorn, https://www.usenix.org/legacy/event/hotsec07/tech/full_papers/mccune/mccune_html/index.html [2] \"Remote Attestation Procedures Architecture\", H. Birkholz, D. Thaler, M. Richardson, N. Smith, W. Pan, https://datatracker.ietf.org/doc/draft-ietf-rats-architecture/ [3] \"Fobnail Token provisioning - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://drive.google.com/file/d/143wW4zWcLbedbuaWMlQpC9f_CMCcXdLH/view?usp=sharing [4] \"External platform provisioning - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://drive.google.com/file/d/1WGBbO9bCFlnarPCZzrKXUjpH4hzbf5l9/view?usp=sharing [5] \"Local platform provisioning - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://drive.google.com/file/d/12gqhdKBlFAMOOkjZu99RPVI_iy_nWfxE/view?usp=sharing [6] \"Local platform provisioning - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://drive.google.com/file/d/1L3CBQsh-qQ4I-7mDj0OYdpK73p_bgKS0/view?usp=sharing [7] \"Attestation - Fobnail architecture\", M. Zmuda, N. Kami\u0144ski, https://tools.ietf.org/id/draft-birkholz-rats-reference-interaction-model-00.html [8] \"CHARRA: CHAllenge-Response based Remote Attestation with TPM 2.0\" https://github.com/Fraunhofer-SIT/charra [9] \"Open Source DRTM implementation with TrenchBoot for AMD processors\" https://nlnet.nl/project/OpenDRTM/ [10] \"The TCG Dynamic Root for Trusted Measurement\", Lee Wilson https://trustedcomputinggroup.org/wp-content/uploads/DRTM-Specification-Overview_June2013.pdf [11] \"LKRG - Linux Kernel Runtime Guard\" https://www.openwall.com/lkrg/","title":"Project description"},{"location":"environment/","text":"Environment setup This document describes hwo to prepare development environment for fobnail. Building docker container For the purpose of fobnail application development we have put necessary software int oa single docker container which we called fobnail SDK . In order to build the container follow the steps below: Install docker using the guide for Linux distribution present on your computer. Add your user to docker group: sudo usermod -aG docker $USER . Then log out of the desktop session then log in again. This step is one-time only. Clone the fobnail SDK repository: git clone https://github.com/fobnail/fobnail-sdk.git Go to fobnail SDK directory: cd fobnail-sdk Execute ./build.sh . It will build the container from the most recent stable software components described in tools-versions file . Components that are used in the process: NRF commandline tools: v10.14.0 Zephyr SDK: v0.13.0 Zephyr RTOS: v2.6.0 Segger JLink: V7.54a cmake: 3.21.2 You will need fobnail-sdk to proceed with any work. The process will take a while to build the container. If we have built the container, time to verify it. We will build a sample application from the fobnail directory using the freshly built docker container. Follow the steps below to test the container: git clone https://github.com/fobnail/fobnail.git cd fobnail git submodule update --init --checkout ./run-container.sh This will launch the container. It will take a moment to initialize when invoke for the first time in given directory. Build a blinky application: west build -b nrf52840dongle_nrf52840 -d build/blinky zephyr/samples/basic/blinky At the end of the process you should see something like this: [138/138] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used FLASH: 12872 B 1020 KB 1.23% SRAM: 4288 B 256 KB 1.64% IDT_LIST: 0 GB 2 KB 0.00% Preparing environment Be sure to have the most recent container compiled as described in Building docker container section. Clone the repository with submodules if you haven't done it yet: git clone https://github.com/fobnail/fobnail.git cd fobnail git submodule update --init --checkout If you have cloned the repository pull the recent changes with git pull . Enter the docker container with ./run-container.sh Note that sometimes the container will not catch the dongle device. In order for the container to see the dongle, plug it first into the USB port (in bootloader mode if needed) and the execute ./run-container.sh .","title":"Environment setup"},{"location":"environment/#environment-setup","text":"This document describes hwo to prepare development environment for fobnail.","title":"Environment setup"},{"location":"environment/#building-docker-container","text":"For the purpose of fobnail application development we have put necessary software int oa single docker container which we called fobnail SDK . In order to build the container follow the steps below: Install docker using the guide for Linux distribution present on your computer. Add your user to docker group: sudo usermod -aG docker $USER . Then log out of the desktop session then log in again. This step is one-time only. Clone the fobnail SDK repository: git clone https://github.com/fobnail/fobnail-sdk.git Go to fobnail SDK directory: cd fobnail-sdk Execute ./build.sh . It will build the container from the most recent stable software components described in tools-versions file . Components that are used in the process: NRF commandline tools: v10.14.0 Zephyr SDK: v0.13.0 Zephyr RTOS: v2.6.0 Segger JLink: V7.54a cmake: 3.21.2 You will need fobnail-sdk to proceed with any work. The process will take a while to build the container. If we have built the container, time to verify it. We will build a sample application from the fobnail directory using the freshly built docker container. Follow the steps below to test the container: git clone https://github.com/fobnail/fobnail.git cd fobnail git submodule update --init --checkout ./run-container.sh This will launch the container. It will take a moment to initialize when invoke for the first time in given directory. Build a blinky application: west build -b nrf52840dongle_nrf52840 -d build/blinky zephyr/samples/basic/blinky At the end of the process you should see something like this: [138/138] Linking C executable zephyr/zephyr.elf Memory region Used Size Region Size %age Used FLASH: 12872 B 1020 KB 1.23% SRAM: 4288 B 256 KB 1.64% IDT_LIST: 0 GB 2 KB 0.00%","title":"Building docker container"},{"location":"environment/#preparing-environment","text":"Be sure to have the most recent container compiled as described in Building docker container section. Clone the repository with submodules if you haven't done it yet: git clone https://github.com/fobnail/fobnail.git cd fobnail git submodule update --init --checkout If you have cloned the repository pull the recent changes with git pull . Enter the docker container with ./run-container.sh Note that sometimes the container will not catch the dongle device. In order for the container to see the dongle, plug it first into the USB port (in bootloader mode if needed) and the execute ./run-container.sh .","title":"Preparing environment"},{"location":"flashing_samples/","text":"Flashing sample applications Preparing environment Prepare the development environment first as described in Environment setup document . nRF52840 buttons and LEDs Building and flashing mcuboot MCUboot is a secure bootloader for 32-bit microcontrollers. It also provides options for device firmware upgrade, e.g. via USB which makes it an ideal target (along with secure boot features) for fobnail. If you prepared the environment properly, you should have cloned the fobnail main repository which contains zephyr and mcuboot. To compile mcuboot follow the steps below: Plug the nRF52840 dongle into the USB port of your computer while holding the reset switch (as shown on the picture above). The red diode (LED2) should start blinking (in fading manner). This means the dongle is in bootloader mode. Yuo may watch the dmesg to see if the USB device appears with sudo dmesg -wH : usb 1-1.4: new full-speed USB device number 62 using ehci-pci usb 1-1.4: New USB device found, idVendor=1915, idProduct=521f, bcdDevice= 1.00 usb 1-1.4: New USB device strings: Mfr=1, Product=2, SerialNumber=3 usb 1-1.4: Product: Open DFU Bootloader usb 1-1.4: Manufacturer: Nordic Semiconductor usb 1-1.4: SerialNumber: EB443991D70D git clone https://github.com/fobnail/fobnail.git if you haven't done it yet. Go to fobnail main repository directory: cd /path/to/fobnail and initialize submodules: git submodule update --init --checkout Run the fobnail-sdk container with ./run-container.sh . Wait or a while while the container initializes the necessary Zephyr modules. When finished (the prompt appears), proceed with next step. Execute make mcuboot_demo dfu . This command will build the mcuboot for nRF52840 dongle and flash it using USB DFU (device firmware upgrade). At the end of the process you should see: Zip created at build/mcuboot.zip [####################################] 100% Device programmed. Now unplug the nRF52840 dongle. In order to prove the process was successful, plug the dongle again into the USB port of your computer but this time, hold the SW1 switch while plugging. The SW1 switch is the white button near the reset button. This will put the dongle into mcuboot bootloader mode. Do not press the reset button as it will put the dongle into Nordic bootloader mode (we do not want this). Note this is different than previous situation, because this time we are using mcuboot instead of stock Nordic's bootlaoder. Unlike Nordic's bootloader, mcuboot does not blink a LED while in bootloader mode so we have to watch dmesg for new USb device sudo dmesg -wH : usb 1-1.4: New USB device found, idVendor=2fe3, idProduct=0100, bcdDevice= 2.06 usb 1-1.4: New USB device strings: Mfr=1, Product=2, SerialNumber=3 usb 1-1.4: Product: MCUBOOT usb 1-1.4: Manufacturer: ZEPHYR usb 1-1.4: SerialNumber: 05AA335B46AC1D80 cdc_acm 1-1.4:1.0: ttyACM0: USB ACM device Notice the different in the Product name: Open DFU Bootloader vs MCUBOOT . This means we have booted the mcuboot in bootloader mode. Building and flashing Zephyr blinyk sample Zephyr is a very popular RTOS which supports a wide variety of microcontrollers including nRF52840 dongle. We will leverage it to show how to launch a sample application on nRF52840 dongle using mcuboot. If you don't have the environment ready go to Preparing environment . In order to flash a sample application on the nRF52840 dongle we will use blinky sample application from Zephyr repository. Follow the steps below to build and flash blinky sample: Put the dongle into mcuboot bootloader mode as instructed in step 6 of Building and flashing mcuboot Go to fobnail main repository directory: cd /path/to/fobnail Run the fobnail-sdk container with ./run-container.sh . This time the container will not initialize the environment if you have done it previously. You will see an error like this (which you may ignore): FATAL ERROR: already initialized in /home/build, aborting. Note: In your environment, ZEPHYR_BASE is set to: /home/build/zephyr This forces west to search for a workspace there. Try unsetting ZEPHYR_BASE and re-running this command. Execute make blinky_demo dfu . This command will build the mcuboot for nRF52840 dongle and flash it using USB DFU (device firmware upgrade). At the end of the process you should see: === image configuration: partition offset: 65536 (0x10000) partition size: 385024 (0x5e000) rom start offset: 512 (0x200) === signing binaries unsigned bin: /home/build/build/blinky/zephyr/zephyr.bin signed bin: build/blinky.signed.bin 13.55 KiB / 13.55 KiB [============================================================================================================================================================] 100.00% 3.09 KiB/s 4s Done Done Notice this time the output from DFU looks different as we are using mcuboot DFU application instead of Nordic's. To verify the process was successful, unplug the dongle and plug it again to the USB port of your CPU. This time do not press any buttons. YOo should notice a green LED blinking (LED1). This means the Zephyr blinky sample has been flashed with USB DFU and launched successfully. Summary MCUboot is a great bootloader with secure boot and USB DFU capabilities for secure applications and great firmware update experience.","title":"Flashing sample applications"},{"location":"flashing_samples/#flashing-sample-applications","text":"","title":"Flashing sample applications"},{"location":"flashing_samples/#preparing-environment","text":"Prepare the development environment first as described in Environment setup document .","title":"Preparing environment"},{"location":"flashing_samples/#nrf52840-buttons-and-leds","text":"","title":"nRF52840 buttons and LEDs"},{"location":"flashing_samples/#building-and-flashing-mcuboot","text":"MCUboot is a secure bootloader for 32-bit microcontrollers. It also provides options for device firmware upgrade, e.g. via USB which makes it an ideal target (along with secure boot features) for fobnail. If you prepared the environment properly, you should have cloned the fobnail main repository which contains zephyr and mcuboot. To compile mcuboot follow the steps below: Plug the nRF52840 dongle into the USB port of your computer while holding the reset switch (as shown on the picture above). The red diode (LED2) should start blinking (in fading manner). This means the dongle is in bootloader mode. Yuo may watch the dmesg to see if the USB device appears with sudo dmesg -wH : usb 1-1.4: new full-speed USB device number 62 using ehci-pci usb 1-1.4: New USB device found, idVendor=1915, idProduct=521f, bcdDevice= 1.00 usb 1-1.4: New USB device strings: Mfr=1, Product=2, SerialNumber=3 usb 1-1.4: Product: Open DFU Bootloader usb 1-1.4: Manufacturer: Nordic Semiconductor usb 1-1.4: SerialNumber: EB443991D70D git clone https://github.com/fobnail/fobnail.git if you haven't done it yet. Go to fobnail main repository directory: cd /path/to/fobnail and initialize submodules: git submodule update --init --checkout Run the fobnail-sdk container with ./run-container.sh . Wait or a while while the container initializes the necessary Zephyr modules. When finished (the prompt appears), proceed with next step. Execute make mcuboot_demo dfu . This command will build the mcuboot for nRF52840 dongle and flash it using USB DFU (device firmware upgrade). At the end of the process you should see: Zip created at build/mcuboot.zip [####################################] 100% Device programmed. Now unplug the nRF52840 dongle. In order to prove the process was successful, plug the dongle again into the USB port of your computer but this time, hold the SW1 switch while plugging. The SW1 switch is the white button near the reset button. This will put the dongle into mcuboot bootloader mode. Do not press the reset button as it will put the dongle into Nordic bootloader mode (we do not want this). Note this is different than previous situation, because this time we are using mcuboot instead of stock Nordic's bootlaoder. Unlike Nordic's bootloader, mcuboot does not blink a LED while in bootloader mode so we have to watch dmesg for new USb device sudo dmesg -wH : usb 1-1.4: New USB device found, idVendor=2fe3, idProduct=0100, bcdDevice= 2.06 usb 1-1.4: New USB device strings: Mfr=1, Product=2, SerialNumber=3 usb 1-1.4: Product: MCUBOOT usb 1-1.4: Manufacturer: ZEPHYR usb 1-1.4: SerialNumber: 05AA335B46AC1D80 cdc_acm 1-1.4:1.0: ttyACM0: USB ACM device Notice the different in the Product name: Open DFU Bootloader vs MCUBOOT . This means we have booted the mcuboot in bootloader mode.","title":"Building and flashing mcuboot"},{"location":"flashing_samples/#building-and-flashing-zephyr-blinyk-sample","text":"Zephyr is a very popular RTOS which supports a wide variety of microcontrollers including nRF52840 dongle. We will leverage it to show how to launch a sample application on nRF52840 dongle using mcuboot. If you don't have the environment ready go to Preparing environment . In order to flash a sample application on the nRF52840 dongle we will use blinky sample application from Zephyr repository. Follow the steps below to build and flash blinky sample: Put the dongle into mcuboot bootloader mode as instructed in step 6 of Building and flashing mcuboot Go to fobnail main repository directory: cd /path/to/fobnail Run the fobnail-sdk container with ./run-container.sh . This time the container will not initialize the environment if you have done it previously. You will see an error like this (which you may ignore): FATAL ERROR: already initialized in /home/build, aborting. Note: In your environment, ZEPHYR_BASE is set to: /home/build/zephyr This forces west to search for a workspace there. Try unsetting ZEPHYR_BASE and re-running this command. Execute make blinky_demo dfu . This command will build the mcuboot for nRF52840 dongle and flash it using USB DFU (device firmware upgrade). At the end of the process you should see: === image configuration: partition offset: 65536 (0x10000) partition size: 385024 (0x5e000) rom start offset: 512 (0x200) === signing binaries unsigned bin: /home/build/build/blinky/zephyr/zephyr.bin signed bin: build/blinky.signed.bin 13.55 KiB / 13.55 KiB [============================================================================================================================================================] 100.00% 3.09 KiB/s 4s Done Done Notice this time the output from DFU looks different as we are using mcuboot DFU application instead of Nordic's. To verify the process was successful, unplug the dongle and plug it again to the USB port of your CPU. This time do not press any buttons. YOo should notice a green LED blinking (LED1). This means the Zephyr blinky sample has been flashed with USB DFU and launched successfully.","title":"Building and flashing Zephyr blinyk sample"},{"location":"flashing_samples/#summary","text":"MCUboot is a great bootloader with secure boot and USB DFU capabilities for secure applications and great firmware update experience.","title":"Summary"},{"location":"resources/","text":"Resources nRF52840 dongle schematics nRF52840 development kit schematics nRF52840 dongle user guide nRF52840 development kit user guide","title":"Resources"},{"location":"resources/#resources","text":"nRF52840 dongle schematics nRF52840 development kit schematics nRF52840 dongle user guide nRF52840 development kit user guide","title":"Resources"}]}